<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AquaSwarm 3D — Full Simulation</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@400;700;900&display=swap');
:root{--navy:#040e1a;--cyan:#00d4ff;--red:#c41e3a;--green:#00ff88;--amber:#ffaa00;--mono:'Share Tech Mono',monospace;--head:'Barlow Condensed',sans-serif;}
*{margin:0;padding:0;box-sizing:border-box;}
body{background:var(--navy);color:#cce8f0;font-family:var(--mono);overflow:hidden;height:100vh;}
#three{position:fixed;inset:0;z-index:0;}

header{
  position:fixed;top:0;left:0;right:0;z-index:10;
  display:flex;align-items:center;justify-content:space-between;
  padding:10px 20px;background:rgba(4,14,26,0.92);
  border-bottom:1px solid rgba(0,212,255,0.18);backdrop-filter:blur(12px);
}
.logo{font-family:var(--head);font-weight:900;font-size:20px;letter-spacing:4px;color:var(--cyan);text-transform:uppercase;}
.logo span{color:var(--red);}
.logo sub{font-size:9px;font-family:var(--mono);color:rgba(0,212,255,0.4);letter-spacing:2px;display:block;}
.hpills{display:flex;gap:8px;}
.pill{font-size:9px;letter-spacing:1.5px;padding:3px 9px;border:1px solid;border-radius:1px;}
.pc{border-color:rgba(0,212,255,0.3);color:var(--cyan);}
.pr{border-color:rgba(196,30,58,0.4);color:var(--red);animation:blink 2s infinite;}
.pg{border-color:rgba(0,255,136,0.3);color:var(--green);}
.pa{border-color:rgba(255,170,0,0.3);color:var(--amber);}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.4}}

#leftPanel{
  position:fixed;left:0;top:57px;bottom:0;width:250px;z-index:10;
  background:rgba(4,14,26,0.9);border-right:1px solid rgba(0,212,255,0.1);
  backdrop-filter:blur(10px);display:flex;flex-direction:column;overflow-y:auto;
}
.psec{padding:13px 15px;border-bottom:1px solid rgba(0,212,255,0.07);}
.ptitle{font-size:8px;letter-spacing:3px;color:var(--cyan);text-transform:uppercase;margin-bottom:10px;display:flex;align-items:center;gap:6px;}
.ptitle::before{content:'';display:block;width:3px;height:11px;background:var(--red);flex-shrink:0;}

.btn{font-family:var(--head);font-size:12px;font-weight:700;letter-spacing:2px;text-transform:uppercase;padding:8px 12px;border:1px solid;cursor:pointer;transition:all .15s;background:transparent;width:100%;text-align:left;margin-bottom:5px;}
.bc{border-color:var(--cyan);color:var(--cyan);}  .bc:hover,.bc.on{background:var(--cyan);color:#04101a;}
.br{border-color:var(--red);color:var(--red);}    .br:hover{background:var(--red);color:#fff;}
.ba{border-color:var(--amber);color:var(--amber);}.ba:hover{background:var(--amber);color:#04101a;}
.bg{border-color:var(--green);color:var(--green);}.bg:hover{background:var(--green);color:#04101a;}

.slg{margin-bottom:10px;}
.sll{display:flex;justify-content:space-between;font-size:9px;color:rgba(0,212,255,.55);margin-bottom:4px;}
input[type=range]{-webkit-appearance:none;width:100%;height:2px;background:rgba(0,212,255,.18);outline:none;}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:11px;height:11px;border-radius:50%;background:var(--cyan);cursor:pointer;box-shadow:0 0 5px var(--cyan);}

.tgrid{display:grid;grid-template-columns:1fr 1fr;gap:5px;}
.tbox{padding:7px;border:1px solid rgba(0,212,255,.1);background:rgba(0,212,255,.03);}
.tv{font-size:18px;color:var(--cyan);line-height:1;}
.tv.g{color:var(--green);}.tv.a{color:var(--amber);}.tv.r{color:var(--red);}
.tk{font-size:7px;color:rgba(0,212,255,.4);letter-spacing:1px;margin-top:2px;}

.rlist{display:flex;flex-direction:column;gap:4px;}
.rc{display:grid;grid-template-columns:20px 1fr auto;align-items:center;gap:7px;padding:5px 7px;border:1px solid rgba(0,212,255,.1);background:rgba(0,212,255,.02);}
.rc.act{border-color:rgba(0,212,255,.3);}
.rc.ret{border-color:rgba(255,170,0,.35);}
.rc.chg{border-color:rgba(0,255,136,.35);background:rgba(0,255,136,.04);}
.rc.dis{opacity:.35;}
.rid{font-size:10px;color:var(--cyan);text-align:center;}
.rst{font-size:8px;color:rgba(255,255,255,.4);}
.bbar{height:2px;background:rgba(255,255,255,.08);margin-top:3px;}
.bfill{height:100%;transition:width .5s,background .5s;}
.rpct{font-size:9px;}

.log{font-size:8px;line-height:1.9;max-height:140px;overflow-y:auto;}
.le{display:flex;gap:5px;}
.lt{color:rgba(0,212,255,.3);flex-shrink:0;}
.lm.w{color:var(--amber);}.lm.ok{color:var(--green);}.lm.al{color:var(--red);}

.dbadge{margin:14px;padding:10px;border:1px solid rgba(196,30,58,.3);background:rgba(196,30,58,.04);text-align:center;}
.dbt{font-family:var(--head);font-size:8px;letter-spacing:3px;color:var(--red);margin-bottom:4px;}
.dbb{font-size:7px;color:rgba(255,255,255,.3);line-height:1.7;}

/* RIGHT HUD */
#rhud{position:fixed;right:0;top:57px;width:175px;z-index:10;pointer-events:none;}
.hbox{margin:8px;padding:9px;background:rgba(4,14,26,.85);border:1px solid rgba(0,212,255,.12);backdrop-filter:blur(8px);}
.htitle{font-size:7px;letter-spacing:2px;color:rgba(0,212,255,.45);margin-bottom:5px;}
.cbar{height:3px;background:rgba(0,212,255,.1);margin-top:4px;}
.cfill{height:100%;background:linear-gradient(90deg,#00a8cc,#00d4ff);box-shadow:0 0 4px #00d4ff;transition:width .8s;}

/* DEBRIS COUNTER badge */
#debrisBadge{
  position:fixed;top:70px;left:50%;transform:translateX(-50%);z-index:15;
  display:flex;gap:12px;
  background:rgba(4,14,26,.88);border:1px solid rgba(0,212,255,.15);
  padding:6px 18px;backdrop-filter:blur(8px);
  font-size:10px;letter-spacing:1.5px;pointer-events:none;
}
.dbitem{display:flex;align-items:center;gap:6px;}
.dbi-dot{width:7px;height:7px;border-radius:50%;}

.hint{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);z-index:5;font-size:8px;color:rgba(0,212,255,.25);letter-spacing:1.5px;pointer-events:none;}
::-webkit-scrollbar{width:3px;} ::-webkit-scrollbar-thumb{background:rgba(0,212,255,.2);}

/* DOCK label */
.dock-label{
  position:fixed;right:185px;top:85px;z-index:12;
  font-size:8px;letter-spacing:2px;color:var(--amber);
  border:1px solid rgba(255,170,0,.3);padding:3px 8px;
  background:rgba(4,14,26,.8);pointer-events:none;
  animation:blink 2.5s infinite;
}
</style>
</head>
<body>
<div id="three"></div>

<header>
  <div>
    <div class="logo">Aqua<span>Swarm</span> <sub>3D SIMULATION — DEBRIS + SURFACE DOCK</sub></div>
  </div>
  <div class="hpills">
    <div class="pill pg">● SONAR ACTIVE</div>
    <div class="pill pr">✕ RF DENIED</div>
    <div class="pill pc">IMU DEAD RECKONING</div>
    <div class="pill pa">⚡ SURFACE DOCK</div>
  </div>
</header>

<div id="debrisBadge">
  <div class="dbitem"><div class="dbi-dot" style="background:#8B4513"></div><span id="debTotal">0</span> DEBRIS TOTAL</div>
  <div class="dbitem"><div class="dbi-dot" style="background:#00ff88"></div><span id="debCleaned">0</span> COLLECTED</div>
  <div class="dbitem"><div class="dbi-dot" style="background:#ffaa00"></div><span id="debPct">0%</span> CLEAN</div>
</div>

<div id="leftPanel">
  <div class="psec">
    <div class="ptitle">Mission Control</div>
    <button class="btn bc" id="btnL" onclick="toggleSim()">▶ LAUNCH SWARM</button>
    <button class="btn ba" onclick="spawnDebris(20)">+ SPAWN DEBRIS ×20</button>
    <button class="btn br" onclick="recallAll()">⬤ EMERGENCY RECALL</button>
    <button class="btn bg" onclick="resetDebris()">↺ RESET POOL</button>
  </div>

  <div class="psec">
    <div class="ptitle">Camera</div>
    <button class="btn bc" onclick="setCam('iso')" style="font-size:10px;margin-bottom:3px">ISOMETRIC</button>
    <button class="btn bc" onclick="setCam('top')" style="font-size:10px;margin-bottom:3px">TOP DOWN</button>
    <button class="btn bc" onclick="setCam('side')" style="font-size:10px">SIDE VIEW</button>
  </div>

  <div class="psec">
    <div class="ptitle">Parameters</div>
    <div class="slg"><div class="sll"><span>SWARM SIZE</span><span id="ssv">5</span></div><input type="range" min="2" max="10" value="5" id="ss" oninput="onP()"></div>
    <div class="slg"><div class="sll"><span>SPEED</span><span id="spv">1.0x</span></div><input type="range" min="3" max="20" value="10" id="sp" oninput="onP()"></div>
    <div class="slg"><div class="sll"><span>BATTERY DRAIN</span><span id="bdv">1.0x</span></div><input type="range" min="1" max="10" value="3" id="bd" oninput="onP()"></div>
    <div class="slg"><div class="sll"><span>SONAR RANGE</span><span id="srv">50</span></div><input type="range" min="20" max="100" value="50" id="sr" oninput="onP()"></div>
  </div>

  <div class="psec">
    <div class="ptitle">Fleet Telemetry</div>
    <div class="tgrid">
      <div class="tbox"><div class="tv g" id="tClean">0%</div><div class="tk">DEBRIS CLEAN</div></div>
      <div class="tbox"><div class="tv" id="tAct">0</div><div class="tk">ACTIVE</div></div>
      <div class="tbox"><div class="tv a" id="tBat">--</div><div class="tk">AVG BAT</div></div>
      <div class="tbox"><div class="tv a" id="tChg">0</div><div class="tk">CHARGING</div></div>
    </div>
  </div>

  <div class="psec">
    <div class="ptitle">Unit Status</div>
    <div class="rlist" id="rlist"></div>
  </div>

  <div class="psec" style="flex:1">
    <div class="ptitle">System Log</div>
    <div class="log" id="slog"></div>
  </div>

  <div class="dbadge">
    <div class="dbt">⬡ DUAL-USE TECH</div>
    <div class="dbb">COMM-INDEPENDENT · EMCON<br>INDOPACOM SBIR / DIU</div>
  </div>
</div>

<div id="rhud">
  <div class="hbox">
    <div class="htitle">DEBRIS CLEANED</div>
    <div class="tv g" id="hudClean" style="font-size:26px">0%</div>
    <div class="cbar"><div class="cfill" id="cfill" style="width:0%"></div></div>
  </div>
  <div class="hbox" style="margin-top:0">
    <div class="htitle">MISSION TIME</div>
    <div class="tv" id="hudTime" style="font-size:16px">00:00</div>
  </div>
  <div class="hbox" style="margin-top:0">
    <div class="htitle">DOCK STATUS</div>
    <div id="dockStatus" style="font-size:10px;color:var(--green)">READY</div>
  </div>
</div>

<div class="dock-label" id="dockLbl">⚡ WIRELESS CHARGING PAD</div>
<div class="hint">DRAG TO ROTATE · SCROLL TO ZOOM</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ══════════════════════════════════════════════════════════
// THREE.JS SETUP
// ══════════════════════════════════════════════════════════
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x04080f);
scene.fog = new THREE.FogExp2(0x04080f, 0.016);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.getElementById('three').appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 600);
camera.position.set(0, 65, 85);
camera.lookAt(0,0,0);

scene.add(new THREE.AmbientLight(0x0a1a30, 2));
const sun = new THREE.DirectionalLight(0x88ccff, 0.8);
sun.position.set(20,50,20); scene.add(sun);
const poolGlow = new THREE.PointLight(0x0044aa, 1.2, 90);
poolGlow.position.set(0,-8,0); scene.add(poolGlow);

// ── ORBIT ──────────────────────────────────────────────────
let sph={theta:0.5,phi:0.85,r:110}, tSph={...sph};
let drag=false, rightDrag=false, pm={x:0,y:0};
const pan=new THREE.Vector3();

renderer.domElement.addEventListener('mousedown',e=>{drag=true;rightDrag=e.button===2;pm={x:e.clientX,y:e.clientY};});
renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('mousemove',e=>{
  if(!drag)return;
  const dx=e.clientX-pm.x,dy=e.clientY-pm.y;
  if(rightDrag){const r=new THREE.Vector3();camera.getWorldDirection(r);r.cross(camera.up).normalize();pan.addScaledVector(r,-dx*.08);pan.addScaledVector(camera.up,dy*.08);}
  else{tSph.theta-=dx*.008;tSph.phi=Math.max(.05,Math.min(Math.PI*.46,tSph.phi+dy*.008));}
  pm={x:e.clientX,y:e.clientY};
});
window.addEventListener('mouseup',()=>drag=false);
renderer.domElement.addEventListener('wheel',e=>{tSph.r=Math.max(20,Math.min(220,tSph.r+e.deltaY*.1));});
window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});

function camTick(){
  sph.theta+=(tSph.theta-sph.theta)*.08;
  sph.phi+=(tSph.phi-sph.phi)*.08;
  sph.r+=(tSph.r-sph.r)*.08;
  const x=sph.r*Math.sin(sph.phi)*Math.sin(sph.theta)+pan.x;
  const y=sph.r*Math.cos(sph.phi)+pan.y;
  const z=sph.r*Math.sin(sph.phi)*Math.cos(sph.theta)+pan.z;
  camera.position.set(x,y,z);
  camera.lookAt(pan.x,pan.y,pan.z);
}
function setCam(m){
  if(m==='top'){tSph.phi=.04;tSph.r=110;}
  else if(m==='iso'){tSph.theta=.6;tSph.phi=.85;tSph.r=110;}
  else if(m==='side'){tSph.phi=Math.PI/2-.04;tSph.r=110;}
}

// ══════════════════════════════════════════════════════════
// POOL WORLD
// ══════════════════════════════════════════════════════════
const PW=70, PD=42, PH=9; // width, depth(z), height(y)
const WATER_Y=0;
const FLOOR_Y=-PH;

// FLOOR
const floorG=new THREE.PlaneGeometry(PW,PD,28,16);
const floorM=new THREE.MeshPhongMaterial({color:0x08203a,emissive:0x001828,emissiveIntensity:.6});
const floor=new THREE.Mesh(floorG,floorM);
floor.rotation.x=-Math.PI/2; floor.position.y=FLOOR_Y;
scene.add(floor);

// GRID on floor
const grid=new THREE.GridHelper(PW,28,0x00d4ff,0x00d4ff);
grid.material.opacity=.06; grid.material.transparent=true;
grid.position.y=FLOOR_Y+.05; scene.add(grid);

// POOL WALLS (transparent)
function wall(w,h,d,x,y,z){
  const g=new THREE.BoxGeometry(w,h,d);
  const m=new THREE.Mesh(g,new THREE.MeshPhongMaterial({color:0x0c2540,transparent:true,opacity:.22,side:THREE.DoubleSide}));
  m.position.set(x,y,z); scene.add(m);
  const e=new THREE.LineSegments(new THREE.EdgesGeometry(g),new THREE.LineBasicMaterial({color:0x00d4ff,transparent:true,opacity:.2}));
  e.position.set(x,y,z); scene.add(e);
}
const wy=FLOOR_Y/2;
wall(PW,PH,.4,0,wy,PD/2); wall(PW,PH,.4,0,wy,-PD/2);
wall(.4,PH,PD,-PW/2,wy,0); wall(.4,PH,PD,PW/2,wy,0);

// WATER SURFACE
const waterG=new THREE.PlaneGeometry(PW,PD);
const waterM=new THREE.MeshPhongMaterial({color:0x003366,transparent:true,opacity:.32,side:THREE.DoubleSide,shininess:100});
const waterMesh=new THREE.Mesh(waterG,waterM);
waterMesh.rotation.x=-Math.PI/2; waterMesh.position.y=WATER_Y+.05;
scene.add(waterMesh);

// LANE DIVIDERS
for(let i=1;i<4;i++){
  const rope=new THREE.Mesh(new THREE.BoxGeometry(.1,.1,PD),new THREE.MeshBasicMaterial({color:0x0044aa}));
  rope.position.set(-PW/2+i*(PW/4),-1,0); scene.add(rope);
}

// ══════════════════════════════════════════════════════════
// POOL DECK & WIRELESS CHARGING PAD (수영장 밖 데크 + 무선 충전 패드)
// ══════════════════════════════════════════════════════════
// DECK GEOMETRY (Concrete surround)
const deckGroup = new THREE.Group();
const deckMat = new THREE.MeshPhongMaterial({color:0x333333, shininess:10});
// Create 4 planes around the pool
// Left
const dLeft = new THREE.Mesh(new THREE.PlaneGeometry(20, PD+20), deckMat);
dLeft.rotation.x = -Math.PI/2; dLeft.position.set(-PW/2 - 10, FLOOR_Y + PH, 0); deckGroup.add(dLeft);
// Right
const dRight = new THREE.Mesh(new THREE.PlaneGeometry(20, PD+20), deckMat);
dRight.rotation.x = -Math.PI/2; dRight.position.set(PW/2 + 10, FLOOR_Y + PH, 0); deckGroup.add(dRight);
// Top
const dTop = new THREE.Mesh(new THREE.PlaneGeometry(PW, 20), deckMat);
dTop.rotation.x = -Math.PI/2; dTop.position.set(0, FLOOR_Y + PH, -PD/2 - 10); deckGroup.add(dTop);
// Bottom
const dBot = new THREE.Mesh(new THREE.PlaneGeometry(PW, 20), deckMat);
dBot.rotation.x = -Math.PI/2; dBot.position.set(0, FLOOR_Y + PH, PD/2 + 10); deckGroup.add(dBot);

scene.add(deckGroup);

// WIRELESS CHARGING PAD (2D Flat Mat)
const PAD_POS = new THREE.Vector3(-PW/2 - 8, FLOOR_Y + PH + 0.05, -PD/2 + 8); // On Left Deck
const padGeo = new THREE.PlaneGeometry(6, 6);
const padMat = new THREE.MeshPhongMaterial({color:0x111111, emissive:0x004400, side:THREE.DoubleSide});
const pad = new THREE.Mesh(padGeo, padMat);
pad.rotation.x = -Math.PI/2;
pad.position.copy(PAD_POS);
scene.add(pad);

// Charging Icon (Simple texture or shape on pad)
const iconGeo = new THREE.RingGeometry(1.5, 2, 32);
const iconMat = new THREE.MeshBasicMaterial({color:0x00ff00, side:THREE.DoubleSide});
const icon = new THREE.Mesh(iconGeo, iconMat);
icon.rotation.x = -Math.PI/2;
icon.position.set(PAD_POS.x, PAD_POS.y + 0.01, PAD_POS.z);
scene.add(icon);

// DOCK_POS variable for robots (center of pad)
const DOCK_POS = PAD_POS.clone();
DOCK_POS.y += 0.5; // Target height above pad

const dockLight = new THREE.PointLight(0xffaa00, 1.5, 30);
dockLight.position.copy(DOCK_POS);
dockLight.position.y += 2;
scene.add(dockLight);

// ══════════════════════════════════════════════════════════
// DEBRIS SYSTEM — 쓰레기!
// ══════════════════════════════════════════════════════════
const debrisPool=[];
let totalDebris=0, cleanedDebris=0;

const DEBRIS_TYPES=[
  // [name, geo, color, size]
  ['leaf',   ()=>new THREE.PlaneGeometry(.6,.4),          0x4a7c20, 1],
  ['sand',   ()=>new THREE.SphereGeometry(.25,6,4),       0xc8a55a, 1],
  ['algae',  ()=>new THREE.TorusGeometry(.3,.1,5,8),      0x2a6a20, 1],
  ['dirt',   ()=>new THREE.SphereGeometry(.18,5,4),       0x5c3a1a, 1],
  ['hair',   ()=>new THREE.CylinderGeometry(.02,.02,.8,4),0x222222, 1],
  ['chip',   ()=>new THREE.BoxGeometry(.3,.05,.3),        0xddccaa, 1],
  ['algae2', ()=>new THREE.BoxGeometry(.5,.05,.4),        0x1a5a10, 1],
];

function spawnDebris(n=20){
  for(let i=0;i<n;i++){
    const t=DEBRIS_TYPES[Math.floor(Math.random()*DEBRIS_TYPES.length)];
    const geo=t[1]();
    const mat=new THREE.MeshPhongMaterial({color:t[2],emissive:t[2],emissiveIntensity:0.3,transparent:true,opacity:.95,side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(geo,mat);
    // Random position on pool floor + random depth scatter
    const depth=Math.random(); // 0=floor, 1=mid water
    mesh.position.set(
      (Math.random()-.5)*(PW-4),
      FLOOR_Y+.15 + depth*(PH-1)*Math.random()*.3,
      (Math.random()-.5)*(PD-4)
    );
    mesh.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI);
    mesh.userData={type:t[0],collected:false,drifting:Math.random()>.7};
    scene.add(mesh);
    debrisPool.push(mesh);
    totalDebris++;
  }
  updateDebrisBadge();
  log(`${n} debris particles spawned in pool`,'w');
}

function resetDebris(){
  debrisPool.forEach(m=>scene.remove(m));
  debrisPool.length=0;
  totalDebris=0; cleanedDebris=0;
  updateDebrisBadge();
  log('Pool reset — debris cleared','ok');
}

function updateDebrisBadge(){
  document.getElementById('debTotal').textContent=totalDebris;
  document.getElementById('debCleaned').textContent=cleanedDebris;
  const pct=totalDebris>0?Math.round(cleanedDebris/totalDebris*100):0;
  document.getElementById('debPct').textContent=pct+'%';
  document.getElementById('hudClean').textContent=pct+'%';
  document.getElementById('cfill').style.width=pct+'%';
  document.getElementById('tClean').textContent=pct+'%';
  document.getElementById('tClean').className='tv '+(pct>75?'g':pct>40?'a':'r');
}

// ══════════════════════════════════════════════════════════
// ROBOTS
// ══════════════════════════════════════════════════════════
const RCOLORS=[0x00d4ff,0x00aaff,0x0088dd,0x44ccff,0x22eeff,0x00bbee,0x66ddff,0x88eeff,0x33bbdd,0x55ccee];
let robots=[], running=false, animId=null, startTs=null, elapsed=0, frameN=0;

// Sonar rings pool
const sonarRings=[];
function mkSonarRing(pos,col){
  const g=new THREE.RingGeometry(0,1,28);
  const m=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:.55,side:THREE.DoubleSide}));
  m.rotation.x=-Math.PI/2; m.position.copy(pos); scene.add(m);
  sonarRings.push({mesh:m,age:0,maxAge:55,maxR:parseFloat(document.getElementById('sr').value)});
}
function tickSonar(){
  for(let i=sonarRings.length-1;i>=0;i--){
    const r=sonarRings[i]; r.age++;
    const t=r.age/r.maxAge;
    r.mesh.scale.setScalar(r.maxR*t);
    r.mesh.material.opacity=.5*(1-t);
    if(r.age>=r.maxAge){scene.remove(r.mesh);sonarRings.splice(i,1);}
  }
}

// Sector assignment
function getSector(i,n){
  const step=PW/n;
  return{x0:-PW/2+i*step, x1:-PW/2+(i+1)*step};
}
function randInSector(sec){
  return new THREE.Vector3(
    sec.x0+Math.random()*(sec.x1-sec.x0),
    FLOOR_Y+.6+Math.random()*.5,
    (Math.random()-.5)*(PD-4)
  );
}

// ══════════════════════════════════════════════════════════
// ROBOT DESIGN (AMPHIBIOUS)
// ══════════════════════════════════════════════════════════
const MAT = {
  hull:    c => new THREE.MeshPhongMaterial({color:c, shininess:80}),
  metal:   c => new THREE.MeshPhongMaterial({color:c, shininess:120, specular:0xffffff}),
  rubber:  c => new THREE.MeshPhongMaterial({color:c, shininess:10, flatShading:true}),
  glow:    (c,e) => new THREE.MeshPhongMaterial({color:c, emissive:e||c, emissiveIntensity:0.6, shininess:30}),
  glass:   c => new THREE.MeshPhongMaterial({color:c, transparent:true, opacity:0.35, shininess:120}),
  wire:    c => new THREE.MeshBasicMaterial({color:c, wireframe:true}),
};

function mkRoboMesh(color){
  const g=new THREE.Group();
  const scale = 0.15; // Scale down from design file size
  const body = new THREE.Group();

  // === CHASSIS ===
  const shape = new THREE.Shape();
  // Design file shape (Type A)
  shape.moveTo(0, 0);
  shape.lineTo(6, 0);      // Bottom
  shape.lineTo(6, 2.5);    // Rear Height
  shape.lineTo(2, 2.0);    // Top slope
  shape.lineTo(0, 0.5);    // Nose
  shape.lineTo(0, 0);

  const extrudeSettings = { steps: 1, depth: 4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 };
  const chassisGeo = new THREE.ExtrudeGeometry( shape, extrudeSettings );
  chassisGeo.center();

  // Use robot color for hull to distinguish them
  const chassisMat = MAT.hull(color);
  const chassis = new THREE.Mesh(chassisGeo, chassisMat);
  body.add(chassis);

  // Wireframe
  const edges = new THREE.LineSegments(new THREE.EdgesGeometry(chassisGeo), new THREE.LineBasicMaterial({color: 0x00d4ff, transparent:true, opacity:0.3}));
  body.add(edges);

  // === TRACKS ===
  const trackGeo = new THREE.BoxGeometry(7.0, 1.8, 0.8);
  const trackMat = MAT.rubber(0x111111);

  const tLeft = new THREE.Mesh(trackGeo, trackMat);
  tLeft.position.set(0, -0.5, 2.2);
  body.add(tLeft);

  const tRight = new THREE.Mesh(trackGeo, trackMat);
  tRight.position.set(0, -0.5, -2.2);
  body.add(tRight);

  // Treads
  for(let side of [1, -1]) {
    for(let i=0; i<10; i++) {
      const tread = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.85, 0.85), MAT.metal(0x222222));
      tread.position.set(-3 + i*0.7, -0.5, side*2.2);
      body.add(tread);
    }
  }

  // === TWIN REAR THRUSTERS ===
  const thrusterGrp = new THREE.Group();
  thrusterGrp.position.set(3.2, 0, 0); // Rear
  for(let side of [1, -1]) {
    const tBody = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 1.2, 16), MAT.metal(0x333333));
    tBody.rotation.z = Math.PI/2;
    tBody.position.set(0, 0.5, side * 1.5);
    thrusterGrp.add(tBody);

    const prop = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.2), MAT.metal(color));
    prop.position.set(0.6, 0.5, side * 1.5);
    thrusterGrp.add(prop);
  }
  body.add(thrusterGrp);

  // === VERTICAL THRUSTER ===
  const vThruster = new THREE.Group();
  vThruster.position.set(0, 1.2, 0);
  const vtBody = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.8, 16), MAT.metal(0x333333));
  vThruster.add(vtBody);
  const vtProp = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.1, 0.2), MAT.metal(color));
  vtProp.position.y = 0.2;
  vThruster.add(vtProp);
  body.add(vThruster);

  // === BRUSH HEAD (Front) ===
  const brushGrp = new THREE.Group();
  brushGrp.position.set(-3.5, -0.8, 0); // Front

  const bRoll = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 3.0, 16), MAT.hull(0x00aa44));
  bRoll.rotation.x = Math.PI/2;
  brushGrp.add(bRoll);

  for(let i=0; i<8; i++) {
      const br = new THREE.Mesh(new THREE.BoxGeometry(0.1, 3.2, 0.8), MAT.glass(0x00ff88));
      br.rotation.x = Math.PI/2;
      br.rotation.z = i * (Math.PI/4);
      brushGrp.add(br);
  }
  body.add(brushGrp);

  // === LIGHT ===
  const light = new THREE.PointLight(color, 0.8, 6);
  light.position.set(-3, 0.5, 0); // Nose
  body.add(light);

  // Apply Transform
  // Design file: Nose at -X, Rear at +X.
  // Simulation: Forward is +Z.
  // Rotate Y +90deg (PI/2) to map -X (Nose) to +Z.
  body.rotation.y = Math.PI/2;
  body.scale.set(scale, scale, scale);

  g.add(body);
  return g;
}

function initRobots(){
  robots.forEach(r=>{scene.remove(r.mesh);r.trails.forEach(l=>scene.remove(l));});
  robots=[];
  const n=parseInt(document.getElementById('ss').value);
  for(let i=0;i<n;i++){
    const col=RCOLORS[i%RCOLORS.length];
    const mesh=mkRoboMesh(col);
    const sec=getSector(i,n);
    mesh.position.set(0, FLOOR_Y+3, 0);
    scene.add(mesh);
    robots.push({
      id:i, mesh, col,
      pos:mesh.position.clone(),
      vel:new THREE.Vector3((Math.random()-.5)*.3,0,(Math.random()-.5)*.3),
      battery:90+Math.random()*10,
      state:'cleaning', // cleaning | seeking_debris | returning | surfacing | charging
      sector:sec,
      target:randInSector(sec),
      debrisTarget:null,
      trails:[],trailPts:[],
      sonarT:Math.floor(Math.random()*70),
      disabled:false,
      chargeTimer:0,
    });
  }
  updateRList();
}

// ══════════════════════════════════════════════════════════
// NEAREST DEBRIS FINDER
// ══════════════════════════════════════════════════════════
function findNearestDebris(pos, sonarR){
  let best=null, bestD=sonarR;
  for(let d of debrisPool){
    if(d.userData.collected) continue;
    // Check if another robot is already targeting this
    const claimed=robots.some(r=>r.debrisTarget===d);
    if(claimed) continue;
    const dist=pos.distanceTo(d.position);
    if(dist<bestD){bestD=dist;best=d;}
  }
  return best;
}

// ══════════════════════════════════════════════════════════
// ROBOT UPDATE
// ══════════════════════════════════════════════════════════
function updateRobots(){
  const speed=parseInt(document.getElementById('sp').value)/10;
  const drain=parseInt(document.getElementById('bd').value)/10;
  const sonarR=parseFloat(document.getElementById('sr').value);
  let chargingCount=0;

  robots.forEach(r=>{
    if(r.disabled)return;
    if(r.battery<=0){r.disabled=true;r.state='disabled';log(`UNIT-${r.id} dead — offline`,'al');return;}

    r.sonarT--;
    if(r.sonarT<=0){mkSonarRing(r.pos.clone(),r.col);r.sonarT=55+Math.floor(Math.random()*35);}

    // ── STATE MACHINE ──────────────────────────────────────

    // 1. CHARGING (On Pad)
    if(r.state==='charging'){
      chargingCount++;
      r.battery=Math.min(100,r.battery+1.5); // Fast wireless charge
      r.chargeTimer++;

      // Position lock on pad
      // Arrange them on the pad
      const targetPos = DOCK_POS.clone().add(new THREE.Vector3((r.id%2)*1.2 - 0.6, 0, (Math.floor(r.id/2)%2)*1.2 - 0.6));
      r.pos.lerp(targetPos, 0.1);
      r.mesh.rotation.set(0,0,0);

      if(r.battery>=100){
        r.state='launching';
        log(`UNIT-${r.id} charged — launching`,'ok');
      }
      r.mesh.position.copy(r.pos);
      return;
    }

    // 2. LAUNCHING (Return to water)
    if(r.state==='launching'){
      // Drive towards pool center
      const poolCenter = new THREE.Vector3(0, FLOOR_Y+2, 0);
      const dir = poolCenter.clone().sub(r.pos).normalize();

      // Move
      r.pos.add(dir.multiplyScalar(speed*0.1));

      // Check if over water (inside pool bounds)
      // Pool X: -35 to 35, Z: -21 to 21
      const safety = 2;
      if(r.pos.x > -PW/2+safety && r.pos.x < PW/2-safety && r.pos.z > -PD/2+safety && r.pos.z < PD/2-safety){
         // Fall
         r.pos.y -= 0.3;
         r.mesh.rotation.x = Math.PI/3; // Nose dive
         if(r.pos.y < WATER_Y - 2){
            r.state='cleaning';
            r.target = randInSector(r.sector);
            r.mesh.rotation.x = 0;
            log(`UNIT-${r.id} splashed down`,'ok');
         }
      } else {
         r.pos.y = FLOOR_Y + PH + 0.2; // Stay on deck
         r.mesh.rotation.set(0, Math.atan2(dir.x, dir.z), 0);
      }
      r.mesh.position.copy(r.pos);
      return;
    }

    // 3. DECK TRAVEL (Climbed wall, moving to pad)
    if(r.state==='deck_travel'){
      // Move to PAD
      const dest = DOCK_POS.clone();
      const dist = r.pos.distanceTo(dest);
      if(dist < 1.0){
        r.state='charging';
        log(`UNIT-${r.id} docked on pad`,'ok');
      } else {
        const dir = dest.sub(r.pos).normalize();
        r.pos.add(dir.multiplyScalar(speed*0.1));
        r.mesh.rotation.set(0, Math.atan2(dir.x, dir.z), 0);
      }
      r.pos.y = FLOOR_Y + PH + 0.2; // Keep on deck height
      r.mesh.position.copy(r.pos);
      return;
    }

    // 4. CLIMBING (Wall climbing with downforce)
    if(r.state==='climbing'){
      // Move UP
      r.pos.y += speed*0.08;

      // Stick to wall X (Left Wall = -PW/2)
      r.pos.x = -PW/2 + 0.5; // Offset

      // Rotation: Vertical, tracks against wall
      // Robot nose points UP (+Y). Bottom is -X.
      // Standard: +Z is nose. +Y is up.
      // We want +Z to point +Y (Up). +Y to point +X (Away from wall).
      r.mesh.rotation.set(0, 0, -Math.PI/2);

      // Transition to Deck
      if(r.pos.y > FLOOR_Y + PH){
        r.state='deck_travel';
        r.pos.y = FLOOR_Y + PH + 0.2;
        r.pos.x = -PW/2 - 1.0; // Pop over lip onto deck
        log(`UNIT-${r.id} climbed deck`,'ok');
      }
      r.mesh.position.copy(r.pos);
      return;
    }

    // 5. SEEKING WALL (Low Battery)
    if(r.state==='seeking_wall'){
      // Go to Left Wall (x = -PW/2)
      const targetX = -PW/2 + 1.5;
      const targetZ = Math.max(-PD/2+2, Math.min(PD/2-2, r.pos.z)); // Stay in bounds Z

      const target = new THREE.Vector3(targetX, r.pos.y, targetZ);
      const toT = target.clone().sub(r.pos);
      const dist = toT.length();

      if(dist < 1.5 || r.pos.x < -PW/2 + 2.5){
         r.state='climbing';
         log(`UNIT-${r.id} engaging wall climb`,'w');
      } else {
         r.vel.lerp(toT.normalize().multiplyScalar(speed), 0.1);
         r.pos.add(r.vel.clone().multiplyScalar(0.4));
         // Orientation
         if(r.vel.length()>.05){
            r.mesh.rotation.y=Math.atan2(r.vel.x,r.vel.z);
            r.mesh.rotation.z=-Math.atan2(r.vel.y,Math.sqrt(r.vel.x**2+r.vel.z**2));
         }
      }
      r.mesh.position.copy(r.pos);
      return;
    }

    // 6. UNDERWATER CLEANING (Standard)

    // Check Battery (Threshold 20%)
    if(r.battery < 20 && r.state !== 'seeking_wall' && r.state !== 'climbing'){
       r.state = 'seeking_wall';
       r.debrisTarget = null;
       log(`UNIT-${r.id} low battery -> RTB`,'w');
    }

    // Debris Logic
    if(debrisPool.length>0){
        if(!r.debrisTarget || r.debrisTarget.userData.collected){
          const nd=findNearestDebris(r.pos, sonarR);
          if(nd){r.debrisTarget=nd; r.state='seeking_debris';}
          else{r.state='cleaning'; r.debrisTarget=null;}
        }
    }

    if(r.state==='seeking_debris' && r.debrisTarget && !r.debrisTarget.userData.collected){
        const toD=r.debrisTarget.position.clone().sub(r.pos);
        if(toD.length()<1.8){
          r.debrisTarget.userData.collected=true;
          r.debrisTarget.visible=false;
          cleanedDebris++;
          updateDebrisBadge();
          r.debrisTarget=null;
          r.state='cleaning';
          r.target=randInSector(r.sector);
        } else {
          r.vel.lerp(toD.normalize().multiplyScalar(speed*1.1),.15);
        }
    } else {
        // Flocking / Patrol
        r.state='cleaning';
        let force=new THREE.Vector3();
        if(r.target){
          const td=r.target.clone().sub(r.pos);
          if(td.length()<2){r.target=randInSector(r.sector);}
          else force.add(td.normalize().multiplyScalar(speed*.8));
        }
        r.vel.add(force);
    }

    // Floor Hugging
    if(r.pos.y > FLOOR_Y+3){r.vel.y-=.1;}
    if(r.pos.y < FLOOR_Y+.5){r.vel.y+=.3;}

    const pad=3;
    if(r.pos.x<-PW/2+pad)r.vel.x+=.4; if(r.pos.x>PW/2-pad)r.vel.x-=.4;
    if(r.pos.z<-PD/2+pad)r.vel.z+=.4; if(r.pos.z>PD/2-pad)r.vel.z-=.4;

    r.battery-=(.006+Math.random()*.003)*drain;

    // Update Pos
    if(r.vel.length()>speed*2.5)r.vel.normalize().multiplyScalar(speed*2.5);
    r.pos.add(r.vel.clone().multiplyScalar(.38));
    r.mesh.position.copy(r.pos);
    if(r.vel.length()>.05){
      r.mesh.rotation.y=Math.atan2(r.vel.x,r.vel.z);
      r.mesh.rotation.z=-Math.atan2(r.vel.y,Math.sqrt(r.vel.x**2+r.vel.z**2));
    }

    // Trail
    r.trailPts.push(r.pos.clone());
    if(r.trailPts.length>35)r.trailPts.shift();
    if(r.trailPts.length>2&&frameN%4===0){
      r.trails.forEach(l=>scene.remove(l));r.trails=[];
      for(let i=1;i<r.trailPts.length;i++){
        const g=new THREE.BufferGeometry().setFromPoints([r.trailPts[i-1],r.trailPts[i]]);
        const l=new THREE.Line(g,new THREE.LineBasicMaterial({color:r.col,transparent:true,opacity:(i/r.trailPts.length)*.22}));
        scene.add(l);r.trails.push(l);
      }
    }

  }); // end forEach

  document.getElementById('tChg').textContent=chargingCount;
  const dockSt=chargingCount>0?`${chargingCount} CHARGING`:robots.some(r=>r.state==='seeking_wall'||r.state==='climbing')?'CLIMBING':'READY';
  document.getElementById('dockStatus').textContent=dockSt;
  document.getElementById('dockStatus').style.color=chargingCount>0?'var(--green)':'var(--cyan)';
}

// ══════════════════════════════════════════════════════════
// UI
// ══════════════════════════════════════════════════════════
function recallAll(){
  robots.forEach(r=>{if(!r.disabled&&r.state!=='charging'&&r.state!=='surfacing'){r.state='returning';r.debrisTarget=null;}});
  log('EMERGENCY RECALL — all units RTB','al');
}

function updateTelemetry(){
  const alive=robots.filter(r=>!r.disabled);
  const active=alive.filter(r=>r.state==='cleaning'||r.state==='seeking_debris').length;
  document.getElementById('tAct').textContent=active;
  const avgBat=alive.length?alive.reduce((s,r)=>s+r.battery,0)/alive.length:0;
  const be=document.getElementById('tBat');
  be.textContent=avgBat.toFixed(0)+'%';
  be.className='tv '+(avgBat>50?'g':avgBat>20?'a':'r');
  const mm=String(Math.floor(elapsed/60000)).padStart(2,'0');
  const ss2=String(Math.floor((elapsed%60000)/1000)).padStart(2,'0');
  document.getElementById('hudTime').textContent=`${mm}:${ss2}`;
}

function updateRList(){
  const el=document.getElementById('rlist');
  const STATE_LABEL={cleaning:'CLEANING',seeking_debris:'→ DEBRIS',returning:'RTB',surfacing:'SURFACING',charging:'⚡ CHG',disabled:'OFFLINE'};
  el.innerHTML=robots.map(r=>{
    const pct=Math.max(0,r.battery).toFixed(0);
    const bc=r.disabled?'#444':r.battery>50?'#00ff88':r.battery>20?'#ffaa00':'#c41e3a';
    const cls=r.disabled?'dis':r.state==='charging'?'chg':r.state==='returning'||r.state==='surfacing'?'ret':'act';
    return`<div class="rc ${cls}">
      <div class="rid">${r.id}</div>
      <div><div class="rst">${STATE_LABEL[r.state]||r.state.toUpperCase()}</div><div class="bbar"><div class="bfill" style="width:${pct}%;background:${bc}"></div></div></div>
      <div class="rpct" style="color:${bc}">${pct}%</div>
    </div>`;
  }).join('');
}

let logLines=[];
function log(msg,type=''){
  const mm=String(Math.floor(elapsed/60000)).padStart(2,'0');
  const ss2=String(Math.floor((elapsed%60000)/1000)).padStart(2,'0');
  logLines.unshift({t:`${mm}:${ss2}`,msg,type});
  if(logLines.length>60)logLines.pop();
  document.getElementById('slog').innerHTML=logLines.slice(0,22).map(l=>`<div class="le"><span class="lt">${l.t}</span><span class="lm ${l.type}">${l.msg}</span></div>`).join('');
}

function onP(){
  document.getElementById('ssv').textContent=document.getElementById('ss').value;
  document.getElementById('spv').textContent=(parseInt(document.getElementById('sp').value)/10).toFixed(1)+'x';
  document.getElementById('bdv').textContent=(parseInt(document.getElementById('bd').value)/10).toFixed(1)+'x';
  document.getElementById('srv').textContent=document.getElementById('sr').value;
}

// ══════════════════════════════════════════════════════════
// MAIN LOOP
// ══════════════════════════════════════════════════════════
function toggleSim(){
  running=!running;
  const btn=document.getElementById('btnL');
  if(running){
    startTs=null;
    initRobots();
    spawnDebris(30);
    log('MISSION START — swarm deployed','ok');
    log('RF DENIED — sonar+IMU nav active','w');
    log('SURFACE DOCK ready at corner','ok');
    btn.textContent='■ ABORT';btn.classList.add('on');
    animId=requestAnimationFrame(loop);
  } else {
    cancelAnimationFrame(animId);
    btn.textContent='▶ LAUNCH SWARM';btn.classList.remove('on');
    log('MISSION ABORTED','al');
  }
}

function loop(ts){
  if(!startTs)startTs=ts;
  elapsed=ts-startTs;
  frameN++;

  if(running)updateRobots();
  tickSonar();

  // Water shimmer
  waterMesh.position.y=WATER_Y+.05+Math.sin(ts*.0012)*.06;
  poolGlow.intensity=1.1+Math.sin(ts*.0018)*.25;
  dockLight.intensity=2+Math.sin(ts*.003)*0.8;
  // light.material.emissiveIntensity=.7+Math.sin(ts*.004)*.3;

  if(frameN%18===0){updateTelemetry();updateRList();}

  camTick();
  renderer.render(scene,camera);
  animId=requestAnimationFrame(loop);
}

// INIT
log('SYSTEM READY','ok');
log('NAV: SONAR + IMU DEAD RECKONING','');
log('RF STATUS: DENIED','w');
log('SURFACE DOCK: STANDBY','ok');
animId=requestAnimationFrame(loop);
</script>
</body>
</html>
